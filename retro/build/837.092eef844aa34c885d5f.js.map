{"version":3,"file":"837.092eef844aa34c885d5f.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../packages/server-extension/lib/index.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport localforage from 'localforage';\n/**\n * The name of the local storage.\n */\nconst STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    constructor() {\n        this._serverContents = new Map();\n        this._isDisposed = false;\n        this._fileChanged = new Signal(this);\n        this._storage = localforage.createInstance({\n            name: STORAGE_NAME,\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            version: 1\n        });\n        this._counters = localforage.createInstance({\n            name: STORAGE_NAME,\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            version: 1\n        });\n        this._checkpoints = localforage.createInstance({\n            name: STORAGE_NAME,\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            version: 1\n        });\n    }\n    /**\n     * A signal emitted when the file has changed.\n     */\n    get fileChanged() {\n        return this._fileChanged;\n    }\n    /**\n     * Test whether the manager has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Return the server settings.\n     */\n    get serverSettings() {\n        // TODO: placeholder\n        return ServerConnection.makeSettings();\n    }\n    /**\n     * Dispose of the resources held by the manager.\n     */\n    dispose() {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        const prefix = path ? `${path}/` : '';\n        let file;\n        let name = '';\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name += `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${prefix}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'text',\n                    mimetype: '',\n                    content: null,\n                    size: undefined,\n                    writable: true,\n                    type: 'directory'\n                };\n                break;\n            }\n            case 'file': {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                name += `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${prefix}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'text',\n                    // TODO: handle mimetypes\n                    mimetype: 'text/plain',\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file'\n                };\n                break;\n            }\n            default: {\n                const counter = await this._incrementCounter('notebook');\n                name += `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${prefix}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: 'application/json',\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook'\n                };\n                break;\n            }\n        }\n        const key = `${prefix}${name}`;\n        await this._storage.setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        item = {\n            ...item,\n            name,\n            path: toPath\n        };\n        await this._storage.setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this.getFolder(path);\n        }\n        const item = await this._storage.getItem(path);\n        const serverItem = await this.getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                ...model,\n                content: null,\n                size: undefined\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await this._storage.iterate((item, key) => {\n                const file = item;\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this.getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: 'application/json',\n                content,\n                size: undefined,\n                writable: true,\n                type: 'directory'\n            };\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async getFolder(path) {\n        const content = new Map();\n        await this._storage.iterate((item, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            const file = item;\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this.getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: 'application/json',\n            content: Array.from(content.values()),\n            size: undefined,\n            writable: true,\n            type: 'directory'\n        };\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. if there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this.getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name) || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: 'text/plain',\n            type: 'file',\n            writable: true,\n            content: null\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this.getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                if (model.type === 'notebook' ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    model = {\n                        ...model,\n                        content: await response.json(),\n                        format: 'json',\n                        mimetype: model.mimetype || 'application/json'\n                    };\n                    // TODO: this is not great, need a better oracle\n                }\n                else if (mimetype.indexOf('xml') !== -1 || mimetype.indexOf('text') !== -1) {\n                    model = {\n                        ...model,\n                        content: await response.text(),\n                        format: 'text',\n                        mimetype: mimetype || 'text/plain'\n                    };\n                }\n                else {\n                    model = {\n                        ...model,\n                        content: btoa(String.fromCharCode(...new Uint8Array(await response.arrayBuffer()))),\n                        format: 'base64',\n                        mimetype: mimetype || 'octet/stream'\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified\n        };\n        await this._storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await this._storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await this._checkpoints.removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        let item = await this.get(path);\n        if (!item) {\n            item = await this.newUntitled({ path });\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified\n        };\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        if (options.content && options.format === 'base64') {\n            // TODO: keep base64 if not a text file (image)\n            const content = atob(options.content);\n            const nb = ext === '.ipynb';\n            item = {\n                ...item,\n                content: nb ? JSON.parse(content) : content,\n                format: nb ? 'json' : 'text',\n                type: nb ? 'notebook' : 'file'\n            };\n        }\n        await this._storage.setItem(path, item);\n        return item;\n    }\n    /**\n     * Delete a file.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const toDelete = [];\n        // handle deleting directories recursively\n        await this._storage.iterate((item, key) => {\n            if (key === path || key.startsWith(`${path}/`)) {\n                toDelete.push(key);\n            }\n        });\n        await Promise.all(toDelete.map(async (p) => {\n            return Promise.all([\n                this._storage.removeItem(p),\n                this._checkpoints.removeItem(p)\n            ]);\n        }));\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const item = await this.get(path, { content: true });\n        const copies = ((_a = (await this._checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(item => !!item);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await this._checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return {\n            id,\n            last_modified: item.last_modified\n        };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = ((await this._checkpoints.getItem(path)) ||\n            []);\n        return copies\n            .filter(item => !!item)\n            .map((file, id) => {\n            return {\n                id: id.toString(),\n                last_modified: file.last_modified\n            };\n        });\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        const copies = ((await this._checkpoints.getItem(path)) ||\n            []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await this._storage.setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        const copies = ((await this._checkpoints.getItem(path)) ||\n            []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await this._checkpoints.setItem(path, copies);\n    }\n    /**\n     * Add an `IDrive` to the manager.\n     */\n    addDrive(drive) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Given a path of the form `drive:local/portion/of/it.txt`\n     * get the local part of it.\n     *\n     * @param path: the path.\n     *\n     * @returns The local part of the path.\n     */\n    localPath(path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Normalize a global path. Reduces '..' and '.' parts, and removes\n     * leading slashes from the local part of the path, while retaining\n     * the drive name if it exists.\n     *\n     * @param path: the path.\n     *\n     * @returns The normalized path.\n     */\n    normalize(path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Resolve a global path, starting from the root path. Behaves like\n     * posix-path.resolve, with 3 differences:\n     *  - will never prepend cwd\n     *  - if root has a drive name, the result is prefixed with \"<drive>:\"\n     *  - before adding drive name, leading slashes are removed\n     *\n     * @param path: the path.\n     *\n     * @returns The normalized path.\n     */\n    resolvePath(root, path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Given a path of the form `drive:local/portion/of/it.txt`\n     * get the name of the drive. If the path is missing\n     * a drive portion, returns an empty string.\n     *\n     * @param path: the path.\n     *\n     * @returns The drive name for the path, or the empty string.\n     */\n    driveName(path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Given a path, get a ModelDB.IFactory from the\n     * relevant backend. Returns `null` if the backend\n     * does not provide one.\n     */\n    getModelDBFactory(path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Get an encoded download url given a file path.\n     *\n     * @param path - An absolute POSIX file path on the server.\n     *\n     * #### Notes\n     * It is expected that the path contains no relative paths.\n     *\n     * The returned URL may include a query parameter.\n     */\n    getDownloadUrl(path) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const current = (_a = (await this._counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await this._counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: []\n    };\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Contents, IContents } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { JupyterServer, LiteServiceManager } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\n/**\n * The contents service plugin.\n */\nconst contents = {\n    id: '@jupyterlite/server-extension:contents',\n    autoStart: true,\n    provides: IContents,\n    activate: (app) => {\n        return new Contents();\n    }\n};\n/**\n * The kernels service plugin.\n */\nconst kernels = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    }\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpec = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs({});\n    }\n};\n/**\n * The sessions service plugin.\n */\nconst sessions = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    }\n};\n/**\n * The server plugin.\n */\nconst server = {\n    id: '@jupyterlite/server-extension:server',\n    autoStart: true,\n    requires: [IContents, IKernels, IKernelSpecs, ISessions, ISettings, ITranslation],\n    activate: (app, contents, kernels, kernelspecs, sessions, settings, translation) => {\n        const jupyterServer = new JupyterServer({\n            contents,\n            kernels,\n            kernelspecs,\n            sessions,\n            settings,\n            translation\n        });\n        const serviceManager = new LiteServiceManager({ server: jupyterServer });\n        app.registerServiceManager(serviceManager);\n    }\n};\n/**\n * The settings service plugin.\n */\nconst settings = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    provides: ISettings,\n    activate: (app) => {\n        return new Settings();\n    }\n};\n/**\n * The translation service plugin.\n */\nconst translation = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        return new Translation();\n    }\n};\nconst plugins = [\n    contents,\n    kernels,\n    kernelSpec,\n    server,\n    sessions,\n    settings,\n    translation\n];\nexport default plugins;\n"],"names":["IContents","Token","STORAGE_NAME","Contents","constructor","this","_serverContents","Map","_isDisposed","_fileChanged","Signal","_storage","name","description","storeName","version","_counters","_checkpoints","ServerConnection","dispose","Error","options","_a","_b","_c","path","type","created","Date","toISOString","prefix","file","_incrementCounter","last_modified","format","mimetype","content","size","undefined","writable","ext","Private","EMPTY_NB","JSON","stringify","length","key","setItem","toDir","PathExt","slice","get","base","replace","toPath","item","decodeURIComponent","getFolder","getItem","serverItem","getServerContents","model","contentMap","iterate","set","serverContents","Array","from","getServerDirectory","values","has","includes","apiURL","URLExt","PageConfig","response","fetch","json","parse","text","err","console","warn","fileUrl","ok","headers","indexOf","match","btoa","String","fromCharCode","Uint8Array","arrayBuffer","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","rename","newUntitled","atob","nb","toDelete","startsWith","push","Promise","all","map","async","p","copies","filter","splice","id","toString","checkpointID","parseInt","addDrive","drive","localPath","normalize","resolvePath","root","driveName","getModelDBFactory","getDownloadUrl","counter","metadata","orig_nbformat","nbformat_minor","nbformat","cells","contents","autoStart","provides","activate","app","kernels","IKernels","requires","IKernelSpecs","kernelspecs","Kernels","kernelSpec","KernelSpecs","sessions","ISessions","Sessions","ISettings","ITranslation","settings","translation","jupyterServer","JupyterServer","serviceManager","LiteServiceManager","server","registerServiceManager","Settings","Translation"],"sourceRoot":""}